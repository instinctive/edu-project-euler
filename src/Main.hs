{-# LANGUAGE TupleSections #-}

module Main where

import Data.NumInstances.Tuple

import qualified Data.IntMap.Strict as I

import Control.Arrow (first)
import Data.Array (Array, (!), array, bounds, listArray)
import Data.Char (digitToInt)
import Data.List (foldl', group, maximumBy, sortBy, tails)
import Data.Ord (comparing)
import System.Environment (getArgs)
import Text.Printf (printf)

type Int2D = Array (Int,Int) Int

type Euler = Int -> Int

euler018 :: [[Int]] -> Euler
euler018 xxx _ = go (reverse xxx) where
    go [[x]] = x
    go (xx:yy:zzz) = go $ tri xx yy : zzz
    go zzz = error $ "go: " ++ show zzz
    tri xx yy = zipWith (+) yy (zipWith max xx (tail xx))

data018 :: [[Int]]
data018 =
    [ [ 75 ]
    , [ 95, 64 ]
    , [ 17, 47, 82 ]
    , [ 18, 35, 87, 10 ]
    , [ 20, 04, 82, 47, 65 ]
    , [ 19, 01, 23, 75, 03, 34 ]
    , [ 88, 02, 77, 73, 07, 63, 67 ]
    , [ 99, 65, 04, 28, 06, 16, 70, 92 ]
    , [ 41, 41, 26, 56, 83, 40, 80, 70, 33 ]
    , [ 41, 48, 72, 33, 47, 32, 37, 16, 94, 29 ]
    , [ 53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14 ]
    , [ 70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57 ]
    , [ 91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48 ]
    , [ 63, 66, 04, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31 ]
    , [ 04, 62, 98, 27, 23, 09, 70, 98, 73, 93, 38, 53, 60, 04, 23 ]
    ]

euler017 :: Euler
euler017 n = sum . map say $ [1..n] where
    say n | n >= 1000 =
        let (q,r) = quotRem n 1000 in
        say q + thou + if r == 0 then 0 else plus + say r
    say n | n >= 100 =
        let (q,r) = quotRem n 100 in
        say q + hund + if r == 0 then 0 else plus + say r
    say n | n >= 20 =
        let (q,r) = quotRem n 10 in
        tens q + if r == 0 then 0 else ones r
    say n | n >= 10 = teen (n-10)
    say n = ones n

    ones = (!!) . map length . words $ "zero one two three four five six seven eight nine"
    teen = (!!) . map length . words $ "ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen"
    tens = (!!) . map length . words $ "zero ten twenty thirty forty fifty sixty seventy eighty ninety"
    hund = length "hundred"
    thou = length "thousand"
    plus = length "and"

euler016 :: Euler
euler016 n = sum . map digitToInt . show . (2^) $ n

euler015 :: Euler
euler015 n = a ! (0,0) where
    a = array ((0,0),(n,n)) $
        ((n,n),1) :
        [ ((y,x), at (y+1) x + at y (x+1))
        | y <- [0..n]
        , x <- [0..n]
        , y * x /= n * n
        ]
    at y x
        | y > n || x > n = 0
        | otherwise      = a ! (y,x)

euler014 :: Euler
euler014 n = fst.fst.foldl' go ((1,1), I.singleton 1 1) . takeWhile (<n) $ [1..] where
    go ((z,v),m) z' =
        let (m',v') = get m z' in
        if v' > v
        then ((z', v'), m')
        else ((z , v ), m')
    get m i
        | i > 100000 = let (m',v) = get m (coll i) in (m', v+1)
        | otherwise  = case I.lookup i m of
            Just v -> (m,v)
            Nothing ->
                let (m',v) = get m (coll i) in
                (I.insert i (v + 1) m', v + 1)
    coll i | even i    = i `div` 2
           | otherwise = i * 3 + 1

collatz :: Int -> [Int]
collatz 1 = [1]
collatz n = n : collatz (go n) where
    go n | even n    = n `div` 2
         | otherwise = 3 * n + 1

euler013 :: [Integer] -> Euler
euler013 xx n = read . take n . show . sum $ xx

data013 :: [Integer]
data013 =
    [ 37107287533902102798797998220837590246510135740250
    , 46376937677490009712648124896970078050417018260538
    , 74324986199524741059474233309513058123726617309629
    , 91942213363574161572522430563301811072406154908250
    , 23067588207539346171171980310421047513778063246676
    , 89261670696623633820136378418383684178734361726757
    , 28112879812849979408065481931592621691275889832738
    , 44274228917432520321923589422876796487670272189318
    , 47451445736001306439091167216856844588711603153276
    , 70386486105843025439939619828917593665686757934951
    , 62176457141856560629502157223196586755079324193331
    , 64906352462741904929101432445813822663347944758178
    , 92575867718337217661963751590579239728245598838407
    , 58203565325359399008402633568948830189458628227828
    , 80181199384826282014278194139940567587151170094390
    , 35398664372827112653829987240784473053190104293586
    , 86515506006295864861532075273371959191420517255829
    , 71693888707715466499115593487603532921714970056938
    , 54370070576826684624621495650076471787294438377604
    , 53282654108756828443191190634694037855217779295145
    , 36123272525000296071075082563815656710885258350721
    , 45876576172410976447339110607218265236877223636045
    , 17423706905851860660448207621209813287860733969412
    , 81142660418086830619328460811191061556940512689692
    , 51934325451728388641918047049293215058642563049483
    , 62467221648435076201727918039944693004732956340691
    , 15732444386908125794514089057706229429197107928209
    , 55037687525678773091862540744969844508330393682126
    , 18336384825330154686196124348767681297534375946515
    , 80386287592878490201521685554828717201219257766954
    , 78182833757993103614740356856449095527097864797581
    , 16726320100436897842553539920931837441497806860984
    , 48403098129077791799088218795327364475675590848030
    , 87086987551392711854517078544161852424320693150332
    , 59959406895756536782107074926966537676326235447210
    , 69793950679652694742597709739166693763042633987085
    , 41052684708299085211399427365734116182760315001271
    , 65378607361501080857009149939512557028198746004375
    , 35829035317434717326932123578154982629742552737307
    , 94953759765105305946966067683156574377167401875275
    , 88902802571733229619176668713819931811048770190271
    , 25267680276078003013678680992525463401061632866526
    , 36270218540497705585629946580636237993140746255962
    , 24074486908231174977792365466257246923322810917141
    , 91430288197103288597806669760892938638285025333403
    , 34413065578016127815921815005561868836468420090470
    , 23053081172816430487623791969842487255036638784583
    , 11487696932154902810424020138335124462181441773470
    , 63783299490636259666498587618221225225512486764533
    , 67720186971698544312419572409913959008952310058822
    , 95548255300263520781532296796249481641953868218774
    , 76085327132285723110424803456124867697064507995236
    , 37774242535411291684276865538926205024910326572967
    , 23701913275725675285653248258265463092207058596522
    , 29798860272258331913126375147341994889534765745501
    , 18495701454879288984856827726077713721403798879715
    , 38298203783031473527721580348144513491373226651381
    , 34829543829199918180278916522431027392251122869539
    , 40957953066405232632538044100059654939159879593635
    , 29746152185502371307642255121183693803580388584903
    , 41698116222072977186158236678424689157993532961922
    , 62467957194401269043877107275048102390895523597457
    , 23189706772547915061505504953922979530901129967519
    , 86188088225875314529584099251203829009407770775672
    , 11306739708304724483816533873502340845647058077308
    , 82959174767140363198008187129011875491310547126581
    , 97623331044818386269515456334926366572897563400500
    , 42846280183517070527831839425882145521227251250327
    , 55121603546981200581762165212827652751691296897789
    , 32238195734329339946437501907836945765883352399886
    , 75506164965184775180738168837861091527357929701337
    , 62177842752192623401942399639168044983993173312731
    , 32924185707147349566916674687634660915035914677504
    , 99518671430235219628894890102423325116913619626622
    , 73267460800591547471830798392868535206946944540724
    , 76841822524674417161514036427982273348055556214818
    , 97142617910342598647204516893989422179826088076852
    , 87783646182799346313767754307809363333018982642090
    , 10848802521674670883215120185883543223812876952786
    , 71329612474782464538636993009049310363619763878039
    , 62184073572399794223406235393808339651327408011116
    , 66627891981488087797941876876144230030984490851411
    , 60661826293682836764744779239180335110989069790714
    , 85786944089552990653640447425576083659976645795096
    , 66024396409905389607120198219976047599490197230297
    , 64913982680032973156037120041377903785566085089252
    , 16730939319872750275468906903707539413042652315011
    , 94809377245048795150954100921645863754710598436791
    , 78639167021187492431995700641917969777599028300699
    , 15368713711936614952811305876380278410754449733078
    , 40789923115535562561142322423255033685442488917353
    , 44889911501440648020369068063960672322193204149535
    , 41503128880339536053299340368006977710650566631954
    , 81234880673210146739058568557934581403627822703280
    , 82616570773948327592232845941706525094512325230608
    , 22918802058777319719839450180888072429661980811197
    , 77158542502016545090413245809786882778948721859617
    , 72107838435069186155435662884062257473692284509516
    , 20849603980134001723930671666823555245252804609722
    , 53503534226472524250874054075591789781264330331690
    ]

euler012 :: Euler
euler012 n = head . dropWhile ((<=n).ndiv.factors) $ triangle where
    ndiv = product . map (succ.length) . group

triangle :: [Int]
triangle = tail . scanl (+) 0 $ [1..]

factors :: Int -> [Int]
factors n = go n [] primes where
    go 1 dd _ = dd
    go x dd ppp@(p:pp) = case quotRem x p of
        (q,0) -> go q (p:dd) ppp
        _     -> go x    dd  pp

euler011 :: Int2D -> Euler
euler011 a k = maximum $
    map (go xn.horz) [y0..ym] ++
    map (go yn.vert) [x0..xm] ++
    map (uncurry go.fmap dn) diag ++
    map (uncurry go.fmap up) diag
  where
    go = maxop (*) k
    ((y0,x0),(ym,xm)) = bounds a
    yn = ym - y0 + 1
    xn = xm - x0 + 1
    horz y x   = a ! (     y, x0 + x)
    vert x y   = a ! (y0 + y,      x)
    dn (y,x) i = a ! (y0+y+i, x0+x+i)
    up (y,x) i = a ! (ym-y-i, x0+x+i)
    diag =
        [ (n, (y,x))
        | (y,x) <- map (0,) [0..xn-1] ++ map (,0) [1..yn-1]
        , let n = (yn - y) `min` (xn - x)
        , n >= k
        ]

maxop :: (Int -> Int -> Int) -> Int -> Int -> (Int -> Int) -> Int
maxop op k n f = maximum . map (\i -> a!(k,i)) $ [0..n-k] where
    a :: Int2D
    a = array ((1,0),(k,n-1)) $ concatMap elts [1..k]
    elts :: Int -> [((Int,Int),Int)]
    elts 1 = [ ((1,i),x) | i <- [0..n-1], let x = f     i ]
    elts v = [ ((v,i),x) | i <- [0..n-v], let x = get v i ]
    get :: Int -> Int -> Int
    get v i = let d = v `div` 2 in (a!(d,i)) `op` (a!(v-d,i+d))

data011 :: Int2D
data011 = listArray ((0,0),(19,19))
    [ 08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08
    , 49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00
    , 81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65
    , 52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91
    , 22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80
    , 24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50
    , 32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70
    , 67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21
    , 24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72
    , 21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95
    , 78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92
    , 16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57
    , 86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58
    , 19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40
    , 04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66
    , 88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69
    , 04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36
    , 20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16
    , 20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54
    , 01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48
    ]

euler010 :: Euler
euler010 n = sum . takeWhile (<n) $ primes

euler009 :: Euler
euler009 n = head
    [ a*b*c
    | a <- [ 1..  n    `div` 3 ]
    , b <- [ a.. (n-a) `div` 2 ]
    , let c = n - a - b
    , a^2 + b^2 == c^2
    ]

euler008 :: [Int] -> Euler
euler008 xx n = maximum . map (product . take n) . tails $ xx ++ replicate n 0

data008 :: [Int]
data008 = map digitToInt $
    "73167176531330624919225119674426574742355349194934" ++
    "96983520312774506326239578318016984801869478851843" ++
    "85861560789112949495459501737958331952853208805511" ++
    "12540698747158523863050715693290963295227443043557" ++
    "66896648950445244523161731856403098711121722383113" ++
    "62229893423380308135336276614282806444486645238749" ++
    "30358907296290491560440772390713810515859307960866" ++
    "70172427121883998797908792274921901699720888093776" ++
    "65727333001053367881220235421809751254540594752243" ++
    "52584907711670556013604839586446706324415722155397" ++
    "53697817977846174064955149290862569321978468622482" ++
    "83972241375657056057490261407972968652414535100474" ++
    "82166370484403199890008895243450658541227588666881" ++
    "16427171479924442928230863465674813919123162824586" ++
    "17866458359124566529476545682848912883142607690042" ++
    "24219022671055626321111109370544217506941658960408" ++
    "07198403850962455444362981230987879927244284909188" ++
    "84580156166097919133875499200524063689912560717606" ++
    "05886116467109405077541002256983155200055935729725" ++
    "71636269561882670428252483600823257530420752963450"

euler007 :: Euler
euler007 n = primes !! (n-1)

euler006 :: Euler
euler006 n = uncurry (-) . first (^2) . sum . map pairsq $ [1..n]

euler005 :: Euler
euler005 n = product . filter (>0) . map check . takeWhile (<=n) $ primes where
    check p = (p^) . pred . length . takeWhile (not.null) . iterate (divBy p) $ [2..n]
    divBy p xx = [ q | x <- xx, let (q,r) = x `quotRem` p, r == 0 ]

euler004 :: Euler
euler004 n = go 0 (n-1) where
    go v x =
        let cands = map (*x) [x..n-1] in
        if all (<v) cands then v
        else go (maximum $ v : filter palin cands) (x-1)
    palin c = let s = show c in s == reverse s

euler003 :: Euler
euler003 n = go 1 n primes where
    go v 1 _ = v
    go v x ppp@(p:pp)
        | x `mod` p == 0 = go p (x `div` p) ppp
        | otherwise      = go v  x          pp

primes :: [Int]
primes = map fst primesq where
    primesq = map pairsq $ 2 : filter isprime [3,5..]
    isprime n = all ((/=0).(n`mod`).fst) . takeWhile ((<=n).snd) $ primesq

pairsq :: Int -> (Int, Int)
pairsq x = (x, x^2)

euler002 :: Euler
euler002 n = sum . filter even . takeWhile (<n) $ fibs

fibs :: [Int]
fibs = 1 : 2 : zipWith (+) fibs (tail fibs)

euler001 :: Euler
euler001 n = sum . takeWhile (<n) . filter p $ [1..] where
    p x = x `mod` 3 == 0 || x `mod` 5 == 0

main :: IO ()
main = getArgs >>= run . map read

run :: [Int] -> IO ()
run tt = case tt of
    [] -> mapM_ go . zip [(1::Int)..] $ problems
    __ -> mapM_ go . zip tt . map ((problems !!).pred) $ tt
  where
    go (n, (f, i, o)) =
        let x = f i in
        printf "%s: euler%03d %s => %s (%s)\n"
            (if o == x then "Correct" else "Incorrect") n (show i) (show x) (show o)

problems :: [(Euler, Int, Int)]
problems =
    [ (euler001, 1000, 233168)
    , (euler002, 4000000, 4613732)
    , (euler003, 600851475143, 6857)
    , (euler004, 1000, 906609)
    , (euler005, 20, 232792560)
    , (euler006, 100, 25164150)
    , (euler007, 10001, 104743)
    , (euler008 data008, 13, 23514624000)
    , (euler009, 1000, 31875000)
    , (euler010, 2000000, 142913828922)
    , (euler011 data011, 4, 70600674)
    , (euler012, 500, 76576500)
    , (euler013 data013, 10, 5537376230)
    , (euler014, 1000000, 837799)
    , (euler015, 20, 137846528820)
    , (euler016, 1000, 1366)
    , (euler017, 1000, 21124)
    , (euler018 data018, 0, 1074)
    ]

